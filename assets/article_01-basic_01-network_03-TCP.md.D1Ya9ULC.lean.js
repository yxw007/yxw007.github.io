import{_ as a,c as e,a2 as i,o as t}from"./chunks/framework.Dty_nV1T.js";const g=JSON.parse('{"title":"TCP","description":"","frontmatter":{"title":"TCP","author":"Potter","date":"2022/08/08 19:40","tags":["TCP"],"categories":["计算机网络"]},"headers":[],"relativePath":"article/01-basic/01-network/03-TCP.md","filePath":"article/01-basic/01-network/03-TCP.md","lastUpdated":1730972145000}'),r={name:"article/01-basic/01-network/03-TCP.md"};function o(n,l,c,s,p,h){return t(),e("div",null,l[0]||(l[0]=[i('<h1 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h1><p><img src="https://cdn.jsdelivr.net/gh/yxw007/BlogPicBed@master/img/20230312222944.png" alt="&quot;img&quot;"></p><h2 id="名词解释" tabindex="-1">名词解释： <a class="header-anchor" href="#名词解释" aria-label="Permalink to &quot;名词解释：&quot;">​</a></h2><ul><li>Seq：序列（sequence）</li><li>Ack：应答信号（acknowledgment）</li><li>Sync：握手</li><li>PSH：推送数据</li><li>FIN：完成断开(挥手)</li></ul><blockquote><p>TCP数据包结构 <img src="https://cdn.jsdelivr.net/gh/yxw007/BlogPicBed@master/img/20230312224531.png" alt="&quot;img&quot;"></p></blockquote><h2 id="建立连接-3次握手" tabindex="-1">建立连接：3次握手 <a class="header-anchor" href="#建立连接-3次握手" aria-label="Permalink to &quot;建立连接：3次握手&quot;">​</a></h2><h3 id="指令标识" tabindex="-1">指令标识 <a class="header-anchor" href="#指令标识" aria-label="Permalink to &quot;指令标识&quot;">​</a></h3><ul><li><p>抓包结果</p><p><img src="https://cdn.jsdelivr.net/gh/yxw007/BlogPicBed@master/img/20220807161123.png" alt="https://cdn.jsdelivr.net/gh/yxw007/BlogPicBed@master/img/20220807161123.png"></p></li><li><p>图解过程</p><p><img src="https://cdn.jsdelivr.net/gh/yxw007/BlogPicBed@master/img/20230312224647.jpg" alt="&quot;img&quot;"></p><p>解释</p><ul><li>从Seq=0开始</li><li>响应过程：本次Seq=上次Ack（没有就是0），本次Ack = 上次seq + 1</li></ul></li></ul><h3 id="通俗表述" tabindex="-1">通俗表述 <a class="header-anchor" href="#通俗表述" aria-label="Permalink to &quot;通俗表述&quot;">​</a></h3><ol><li>快递员→你 : 有你的快递，请问在家吗?</li><li>你→快递员：在家，送过来吧</li><li>快递员→你：好的</li></ol><h2 id="连接中-数据传输" tabindex="-1">连接中：数据传输 <a class="header-anchor" href="#连接中-数据传输" aria-label="Permalink to &quot;连接中：数据传输&quot;">​</a></h2><ul><li><p>抓包</p><p><img src="https://cdn.jsdelivr.net/gh/yxw007/BlogPicBed@master/img/20230312224745.png" alt="&quot;img&quot;"></p></li><li><p>图解过程</p><p><img src="https://cdn.jsdelivr.net/gh/yxw007/BlogPicBed@master/img/20230312224835.jpeg" alt="&quot;img&quot;"></p><p>解释</p><ul><li>从Seq=1，ack=1 开始</li><li>响应过程：本次Seq=上次Ack，本次Ack = 上次seq + 上次Len</li></ul></li></ul><h2 id="断开连接-4次挥手" tabindex="-1">断开连接：4次挥手 <a class="header-anchor" href="#断开连接-4次挥手" aria-label="Permalink to &quot;断开连接：4次挥手&quot;">​</a></h2><h3 id="指令表述" tabindex="-1">指令表述 <a class="header-anchor" href="#指令表述" aria-label="Permalink to &quot;指令表述&quot;">​</a></h3><ul><li><p>抓包</p><p><img src="https://cdn.jsdelivr.net/gh/yxw007/BlogPicBed@master/img/20230312225139.png" alt="&quot;img&quot;"></p></li><li><p>图解</p><p><img src="https://cdn.jsdelivr.net/gh/yxw007/BlogPicBed@master/img/20230312225208.jpg" alt="&quot;img&quot;"></p><p>解释</p><ul><li>假设从Seq=1，Ack=1 开始（连接后未传送数据）</li><li>响应过程：本次Seq=上次Ack，本次Ack = 上次Seq + 1（实际不管从Seq和ACK到多少也是遵从这个逻辑）</li></ul></li></ul><blockquote><p>确认过程：都是Ack = 上次Seq + 1（如果是传送中就是+Len），Seq = 上次Ack</p></blockquote><h3 id="通俗表述-1" tabindex="-1">通俗表述 <a class="header-anchor" href="#通俗表述-1" aria-label="Permalink to &quot;通俗表述&quot;">​</a></h3><ol><li>男→女：我们分手吧？</li><li>女→男：好，等下我把你以前的东西都找出来给你</li><li>女→男：你的东西都给你了，再见</li><li>男→女：再见</li></ol><h2 id="tcp-特点" tabindex="-1">TCP 特点 <a class="header-anchor" href="#tcp-特点" aria-label="Permalink to &quot;TCP 特点&quot;">​</a></h2><p>缺点：</p><ol><li>对头阻塞</li><li>客户端大量端口被占用：服务端最后的ack未给到客户端</li><li>慢启动</li><li>粘包</li></ol><p>优点：</p><ol><li><p>实时性好</p></li><li><p>滑动窗口，对头阻塞（可靠，能保证顺序）</p><ol><li>通过窗口大小，进行拥塞控制</li></ol></li><li><p>有发送和接收缓存区</p></li><li><p>粘包：（流量控制）</p><ol><li><strong><strong><a href="https://www.cnblogs.com/tangr206/articles/3115586.html" target="_blank" rel="noreferrer">Nagle 算法 &amp;&amp; CORK算法</a></strong></strong></li></ol></li></ol><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li><strong><strong><a href="https://www.cnblogs.com/tangr206/articles/3115586.html" target="_blank" rel="noreferrer">Nagle 算法 &amp;&amp; CORK算法</a></strong></strong></li></ul>',25)]))}const u=a(r,[["render",o]]);export{g as __pageData,u as default};
